# Vue2 数组方法重写分析

## 1. 为什么需要重写数组方法？

Vue2的响应式系统基于`Object.defineProperty`实现，它只能劫持对象的属性访问，无法直接监听数组的变化。当数组通过索引直接赋值或使用数组方法修改时，Vue2无法检测到这些变化。

### 1.1 问题示例

```javascript
// 这些操作Vue2无法检测到
const arr = [1, 2, 3]
arr[0] = 4           // 直接索引赋值
arr.length = 0       // 修改length
arr.push(4)          // 数组方法（需要重写）
arr.splice(0, 1)     // 数组方法（需要重写）
```

## 2. 数组方法重写的实现

### 2.1 核心文件结构

```
src/core/observer/
├── array.ts          # 数组方法重写
├── index.ts          # Observer类
└── dep.ts           # 依赖收集器
```

### 2.2 重写的数组方法

Vue2重写了以下7个会改变数组本身的方法：

```typescript
const methodsToPatch = [
  'push',      // 向数组末尾添加元素
  'pop',       // 删除数组最后一个元素
  'shift',     // 删除数组第一个元素
  'unshift',   // 向数组开头添加元素
  'splice',    // 删除/替换/插入元素
  'sort',      // 排序
  'reverse'    // 反转
]
```

## 3. 具体实现分析

### 3.1 创建数组方法对象

```typescript
// src/core/observer/array.ts
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop', 
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    if (__DEV__) {
      ob.dep.notify({
        type: TriggerOpTypes.ARRAY_MUTATION,
        target: this,
        key: method
      })
    } else {
      ob.dep.notify()
    }
    return result
  })
})
```

### 3.2 关键实现细节

#### 3.2.1 保存原始方法

```typescript
const original = arrayProto[method]
```

首先保存数组原型上的原始方法，以便在重写的方法中调用。

#### 3.2.2 创建重写方法

```typescript
def(arrayMethods, method, function mutator(...args) {
  // 调用原始方法
  const result = original.apply(this, args)
  
  // 获取Observer实例
  const ob = this.__ob__
  
  // 处理新增的元素
  let inserted
  switch (method) {
    case 'push':
    case 'unshift':
      inserted = args
      break
    case 'splice':
      inserted = args.slice(2)
      break
  }
  
  // 对新元素进行响应式处理
  if (inserted) ob.observeArray(inserted)
  
  // 通知依赖更新
  ob.dep.notify()
  
  return result
})
```

#### 3.2.3 处理新增元素

对于会新增元素的方法（`push`、`unshift`、`splice`），需要对新元素进行响应式处理：

```typescript
let inserted
switch (method) {
  case 'push':
  case 'unshift':
    inserted = args  // 所有参数都是新增的元素
    break
  case 'splice':
    inserted = args.slice(2)  // splice的第三个参数开始是新增的元素
    break
}
if (inserted) ob.observeArray(inserted)
```

### 3.3 Observer类中的数组处理

```typescript
// src/core/observer/index.ts
export class Observer {
  constructor(public value: any, public shallow = false, public mock = false) {
    this.dep = mock ? mockDep : new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    
    if (isArray(value)) {
      if (!mock) {
        if (hasProto) {
          // 使用__proto__设置原型
          ;(value as any).__proto__ = arrayMethods
        } else {
          // 兼容不支持__proto__的环境
          for (let i = 0, l = arrayKeys.length; i < l; i++) {
            const key = arrayKeys[i]
            def(value, key, arrayMethods[key])
          }
        }
      }
      if (!shallow) {
        this.observeArray(value)
      }
    } else {
      // 处理对象
      const keys = Object.keys(value)
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i]
        defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock)
      }
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray(value: any[]) {
    for (let i = 0, l = value.length; i < l; i++) {
      observe(value[i], false, this.mock)
    }
  }
}
```

## 4. 实现原理详解

### 4.1 原型链重写

Vue2通过重写数组的原型链来实现方法拦截：

```typescript
// 方式1：使用__proto__（现代浏览器）
if (hasProto) {
  ;(value as any).__proto__ = arrayMethods
}

// 方式2：直接定义属性（兼容性）
else {
  for (let i = 0, l = arrayKeys.length; i < l; i++) {
    const key = arrayKeys[i]
    def(value, key, arrayMethods[key])
  }
}
```

### 4.2 依赖收集和派发

当数组方法被调用时：

1. **执行原始方法**：先执行数组的原始方法
2. **处理新增元素**：对新添加的元素进行响应式处理
3. **通知依赖**：调用`dep.notify()`通知所有依赖更新

```typescript
// 执行原始方法
const result = original.apply(this, args)

// 处理新增元素
if (inserted) ob.observeArray(inserted)

// 通知依赖更新
ob.dep.notify()
```

## 5. 使用示例

### 5.1 基本用法

```javascript
// Vue实例
const vm = new Vue({
  data: {
    list: [1, 2, 3]
  }
})

// 这些操作会触发响应式更新
vm.list.push(4)        // ✅ 会触发更新
vm.list.splice(0, 1)   // ✅ 会触发更新
vm.list.sort()         // ✅ 会触发更新

// 这些操作不会触发响应式更新
vm.list[0] = 5         // ❌ 不会触发更新
vm.list.length = 0     // ❌ 不会触发更新
```

### 5.2 解决方案

对于Vue2无法检测的数组操作，可以使用以下方法：

```javascript
// 1. 使用Vue.set
Vue.set(vm.list, 0, 5)

// 2. 使用vm.$set
vm.$set(vm.list, 0, 5)

// 3. 使用数组方法
vm.list.splice(0, 1, 5)

// 4. 替换整个数组
vm.list = [...vm.list.slice(0, 0), 5, ...vm.list.slice(1)]
```

## 6. 源码中的关键函数

### 6.1 def函数

```typescript
// src/core/util/lang.ts
export function def(obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}
```

`def`函数用于定义不可枚举的属性，避免在`for...in`循环中遍历到这些重写的方法。

### 6.2 observeArray函数

```typescript
observeArray(value: any[]) {
  for (let i = 0, l = value.length; i < l; i++) {
    observe(value[i], false, this.mock)
  }
}
```

`observeArray`函数用于对数组中的每个元素进行响应式处理。

## 7. 性能优化

### 7.1 缓存原始方法

```typescript
const original = arrayProto[method]
```

通过缓存原始方法，避免每次调用时都去原型链上查找。

### 7.2 条件判断

```typescript
if (inserted) ob.observeArray(inserted)
```

只有当有新增元素时才进行响应式处理，避免不必要的性能开销。

## 8. 兼容性处理

### 8.1 __proto__支持检测

```typescript
if (hasProto) {
  ;(value as any).__proto__ = arrayMethods
} else {
  for (let i = 0, l = arrayKeys.length; i < l; i++) {
    const key = arrayKeys[i]
    def(value, key, arrayMethods[key])
  }
}
```

Vue2检测浏览器是否支持`__proto__`，如果不支持则直接定义属性。

## 9. 总结

Vue2的数组方法重写机制通过以下步骤实现：

1. **创建重写方法对象**：基于`Array.prototype`创建新对象
2. **重写变异方法**：拦截7个会改变数组的方法
3. **处理新增元素**：对新元素进行响应式处理
4. **通知依赖更新**：调用`dep.notify()`触发更新
5. **兼容性处理**：支持不同浏览器的原型链操作

这种设计使得Vue2能够检测到数组的变化，同时保持了良好的性能和兼容性。虽然无法检测到所有数组操作（如直接索引赋值），但通过`Vue.set`等方法可以解决这些限制。
