# Vue2 生命周期和渲染系统分析

## 1. 生命周期概述

Vue2的生命周期是Vue框架的核心概念之一，它描述了Vue实例从创建到销毁的整个过程。每个生命周期钩子都有特定的用途和执行时机。

### 1.1 生命周期钩子

```typescript
// Vue2的生命周期钩子
beforeCreate  // 实例初始化之后，数据观测和事件配置之前
created       // 实例创建完成，数据观测、属性和方法的运算、事件回调已配置
beforeMount   // 挂载开始之前，render函数首次被调用
mounted       // 实例挂载完成，DOM已创建
beforeUpdate  // 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前
updated       // 数据更新导致的虚拟DOM重新渲染和打补丁之后
beforeDestroy // 实例销毁之前调用
destroyed     // 实例销毁后调用
```

## 2. 生命周期实现机制

### 2.1 初始化阶段

```typescript
// src/core/instance/init.ts
export function initMixin(Vue: typeof Component) {
  Vue.prototype._init = function (options?: Record<string, any>) {
    const vm: Component = this
    vm._uid = uid++

    // 标记为Vue实例
    vm._isVue = true
    vm.__v_skip = true

    // 合并选项
    if (options && options._isComponent) {
      initInternalComponent(vm, options as any)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor as any),
        options || {},
        vm
      )
    }

    // 初始化代理
    if (__DEV__) {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }

    // 初始化各个模块
    initLifecycle(vm)        // 生命周期
    initEvents(vm)          // 事件
    initRender(vm)          // 渲染
    callHook(vm, 'beforeCreate')  // 调用beforeCreate钩子
    initInjections(vm)      // 注入
    initState(vm)           // 状态
    initProvide(vm)         // 提供
    callHook(vm, 'created') // 调用created钩子

    // 挂载
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
```

### 2.2 挂载阶段

```typescript
// src/core/instance/lifecycle.ts
export function mountComponent(
  vm: Component,
  el: Element | null | undefined,
  hydrating?: boolean
): Component {
  vm.$el = el
  
  // 检查render函数
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
  }

  // 调用beforeMount钩子
  callHook(vm, 'beforeMount')

  // 定义更新组件函数
  let updateComponent
  if (__DEV__ && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // 创建渲染Watcher
  new Watcher(
    vm,
    updateComponent,
    noop,
    {
      before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate')
        }
      }
    },
    true /* isRenderWatcher */
  )

  // 手动挂载的实例，调用mounted钩子
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

### 2.3 更新阶段

```typescript
// src/core/instance/lifecycle.ts
export function lifecycleMixin(Vue: typeof Component) {
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode

    if (!prevVnode) {
      // 初始渲染
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // 更新
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()

    // 更新__vue__引用
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
  }
}
```

## 3. 渲染系统

### 3.1 渲染函数

```typescript
// src/core/instance/render.ts
export function renderMixin(Vue: typeof Component) {
  Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    // 设置父vnode
    vm.$vnode = _parentVnode!

    let vnode
    try {
      // 调用render函数
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e: any) {
      handleError(e, vm, `render`)
      // 返回错误渲染结果或之前的vnode
      if (__DEV__ && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(
            vm._renderProxy,
            vm.$createElement,
            e
          )
        } catch (e: any) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    }

    // 如果返回的是数组且只有一个节点，允许它
    if (isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0]
    }

    // 如果不是VNode实例，创建空VNode
    if (!(vnode instanceof VNode)) {
      if (__DEV__ && isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
            'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }

    // 设置父节点
    vnode.parent = _parentVnode
    return vnode
  }
}
```

### 3.2 虚拟DOM更新

```typescript
// src/core/vdom/patch.ts
export function createPatchFunction(backend) {
  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // 空挂载（可能是组件），创建新元素
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // 修补现有节点
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // 挂载到真实元素
          oldVnode = emptyNodeAt(oldVnode)
        }

        // 替换现有元素
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // 创建新节点
        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // 递归更新父占位符元素
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // 销毁旧节点
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
}
```

## 4. 组件系统

### 4.1 组件创建

```typescript
// src/core/vdom/create-component.ts
export function createComponent(
  Ctor: Class<Component> | Function | Object | void,
  data: VNodeData | undefined,
  context: Component,
  children: Array<VNode> | undefined,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base

  // 普通选项对象：转换为构造函数
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }

  // 异步组件
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag)
    }
  }

  data = data || {}

  // 解析构造函数选项
  resolveConstructorOptions(Ctor)

  // 转换组件v-model数据为props和events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // 提取props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // 函数式组件
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // 提取监听器
  const listeners = data.on
  data.on = data.nativeOn

  // 抽象组件
  if (isTrue(Ctor.options.abstract)) {
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // 安装组件管理钩子
  installComponentHooks(data)

  // 返回占位符vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data,
    undefined,
    undefined,
    undefined,
    context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  return vnode
}
```

### 4.2 组件钩子

```typescript
// src/core/vdom/create-component.ts
const componentVNodeHooks = {
  init(vnode: VNodeWithData, hydrating: boolean): boolean | void {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive组件，作为补丁
      const mountedNode: any = vnode
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = (vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      ))
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch(oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = (vnode.componentInstance = oldVnode.componentInstance)
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert(vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy(vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}
```

## 5. 生命周期钩子调用机制

### 5.1 callHook函数

```typescript
// src/core/instance/lifecycle.ts
export function callHook(
  vm: Component,
  hook: string,
  args?: any[],
  setContext = true
) {
  // 禁用依赖收集
  pushTarget()
  const prevInst = currentInstance
  const prevScope = getCurrentScope()
  setContext && setCurrentInstance(vm)
  
  const handlers = vm.$options[hook]
  const info = `${hook} hook`
  
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, args || null, vm, info)
    }
  }
  
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  
  if (setContext) {
    setCurrentInstance(prevInst)
    prevScope && prevScope.on()
  }
  
  popTarget()
}
```

## 6. 性能优化

### 6.1 渲染性能监控

```typescript
// 性能监控
if (__DEV__ && config.performance && mark) {
  updateComponent = () => {
    const name = vm._name
    const id = vm._uid
    const startTag = `vue-perf-start:${id}`
    const endTag = `vue-perf-end:${id}`

    mark(startTag)
    const vnode = vm._render()
    mark(endTag)
    measure(`vue ${name} render`, startTag, endTag)

    mark(startTag)
    vm._update(vnode, hydrating)
    mark(endTag)
    measure(`vue ${name} patch`, startTag, endTag)
  }
}
```

### 6.2 异步更新队列

```typescript
// src/core/observer/scheduler.ts
const queue: Array<Watcher> = []
let has: { [key: number]: ?true } = {}
let waiting = false
let flushing = false
let index = 0

function flushSchedulerQueue() {
  flushing = true
  let watcher, id

  // 按id排序，确保父组件在子组件之前更新
  queue.sort((a, b) => a.id - b.id)

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    id = watcher.id
    has[id] = null
    watcher.run()
  }

  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  // 调用激活和更新的钩子
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)
}
```

## 7. 总结

Vue2的生命周期和渲染系统通过以下机制实现：

1. **生命周期管理**：
   - 通过`callHook`函数统一调用生命周期钩子
   - 在适当的时机触发相应的钩子
   - 支持错误处理和性能监控

2. **渲染系统**：
   - 基于虚拟DOM的渲染机制
   - 通过`_render`函数生成虚拟节点
   - 通过`_update`函数更新真实DOM

3. **组件系统**：
   - 支持函数式组件和异步组件
   - 通过组件钩子管理组件生命周期
   - 实现组件间的通信和状态管理

4. **性能优化**：
   - 异步更新队列
   - 渲染性能监控
   - 虚拟DOM diff算法

这种设计使得Vue2能够高效地管理组件生命周期，实现响应式更新，并提供良好的开发体验。
