# Vue2 编译器系统分析

## 1. 编译器概述

Vue2的编译器负责将模板字符串转换为渲染函数，工作流程包括：解析（Parse）、优化（Optimize）、生成（Generate）三个阶段。

### 1.1 编译器工作流程

```
Template String → Parse → AST → Optimize → Optimized AST → Generate → Render Function
```

## 2. 编译器架构

### 2.1 核心文件结构

```
src/compiler/
├── index.ts              # 编译器入口
├── create-compiler.ts    # 编译器创建器
├── to-function.ts        # 编译到函数
├── parser/               # 解析器
├── optimizer/            # 优化器
├── codegen/              # 代码生成器
└── directives/           # 指令处理
```

### 2.2 编译器创建

```typescript
// src/compiler/index.ts
export const createCompiler = createCompilerCreator(function baseCompile(
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

## 3. 解析阶段（Parse）

### 3.1 HTML解析器

HTML解析器将模板字符串解析为AST（抽象语法树），处理标签、属性、指令等。

```typescript
// 解析器主要功能
- 解析HTML标签
- 处理属性绑定
- 解析指令（v-if、v-for等）
- 处理插值表达式
- 生成AST节点
```

### 3.2 AST节点结构

```typescript
interface ASTElement {
  type: 1
  tag: string
  attrsList: Array<ASTAttr>
  attrsMap: { [key: string]: string | true }
  parent: ASTElement | void
  children: Array<ASTNode>
  
  // 静态相关
  static?: boolean
  staticRoot?: boolean
  
  // 指令相关
  directives?: Array<ASTDirective>
  events?: { [key: string]: ASTElementHandler }
  
  // 组件相关
  component?: string
  key?: string
  ref?: string
}
```

## 4. 优化阶段（Optimize）

### 4.1 静态节点标记

优化器标记静态节点，避免不必要的重新渲染。

```typescript
function markStatic(node: ASTNode, isOnce: boolean) {
  node.static = isStatic(node)
  if (node.type === 1) {
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i]
      markStatic(child, isOnce || !!node.for)
      if (!child.static) {
        node.static = false
      }
    }
  }
}
```

### 4.2 静态根节点标记

```typescript
function markStaticRoots(node: ASTNode, isInFor: boolean) {
  if (node.type === 1) {
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
  }
}
```

## 5. 代码生成阶段（Generate）

### 5.1 代码生成器

将优化后的AST转换为渲染函数代码。

```typescript
export function generate(
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c("div")'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
```

### 5.2 元素代码生成

```typescript
function genElement(el: ASTElement, state: CodegenState): string {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else {
    // 组件或元素
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      let data
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData(el, state)
      }
      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${data ? `,${data}` : ''}${children ? `,${children}` : ''})`
    }
    return code
  }
}
```

## 6. 指令处理

### 6.1 v-model指令

```typescript
export default function model(
  el: ASTElement,
  dir: ASTDirective,
  _warn: Function
): boolean {
  const value = dir.value
  const modifiers = dir.modifiers
  const tag = el.tag
  const type = el.attrsMap.type

  if (el.component) {
    genComponentModel(el, value, modifiers)
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers)
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers)
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers)
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers)
  }
  return true
}
```

### 6.2 v-on指令

```typescript
export default function on(
  el: ASTElement,
  dir: ASTDirective
) {
  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {
    warn(`v-on without argument does not support modifiers.`)
  }
  el.wrapListeners = (code: string) => `_g(${code},${dir.value})`
}
```

## 7. 编译到函数

### 7.1 编译函数创建

```typescript
export function createCompileToFunctionFn(compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions(
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn

    // 检查缓存
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // 编译
    const compiled = compile(template, options)

    // 转换为函数
    const res = {}
    const fnGenErrors = []
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(code => {
      return createFunction(code, fnGenErrors)
    })

    return (cache[key] = res)
  }
}
```

## 8. 总结

Vue2的编译器系统通过以下机制实现：

1. **解析阶段**：将模板字符串解析为AST
2. **优化阶段**：标记静态节点，优化渲染性能
3. **代码生成阶段**：将AST转换为渲染函数代码
4. **指令处理**：支持v-model、v-on等指令
5. **缓存机制**：避免重复编译相同模板

这种设计使得Vue2能够高效地将模板转换为渲染函数，实现声明式的模板语法。
